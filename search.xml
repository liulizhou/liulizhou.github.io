<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>linux-any-commands</title>
      <link href="/2018/11/16/linux-any-commands/"/>
      <url>/2018/11/16/linux-any-commands/</url>
      
        <content type="html"><![CDATA[<p>本篇文章记录了linux各种各样的非常常用而且重要的命令用法</p><a id="more"></a><h1 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h1><p>我们比较常用的两种查找方式，一种是查找文件中的字符，一种是查找文件</p><h2 id="grep查找文件中的字符"><a href="#grep查找文件中的字符" class="headerlink" title="grep查找文件中的字符"></a>grep查找文件中的字符</h2><p>对文件中的字符进行查找使用grep，grep命令参数如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">maxliu@maxliu-tp:~/eclipse_201908-workspace/pycvt/src/build$ grep --help</span><br><span class="line">用法: grep [选项]... PATTERN [FILE]...</span><br><span class="line">在每个 FILE 或是标准输入中查找 PATTERN。</span><br><span class="line">默认的 PATTERN 是一个基本正则表达式(缩写为 BRE)。</span><br><span class="line">例如: grep -i <span class="string">'hello world'</span> menu.h main.c</span><br><span class="line"></span><br><span class="line">正则表达式选择与解释:</span><br><span class="line">  -E, --extended-regexp     PATTERN 是一个可扩展的正则表达式(缩写为 ERE)</span><br><span class="line">  -F, --fixed-strings       PATTERN 是一组由断行符分隔的字符串。</span><br><span class="line">  -G, --basic-regexp        PATTERN 是一个基本正则表达式(缩写为 BRE)</span><br><span class="line">  -P, --perl-regexp         PATTERN 是一个 Perl 正则表达式</span><br><span class="line">  -e, --regexp=PATTERN      用 PATTERN 来进行匹配操作</span><br><span class="line">  -f, --file=FILE           从 FILE 中取得 PATTERN</span><br><span class="line">  -i, --ignore-case         忽略大小写</span><br><span class="line">  -w, --word-regexp         强制 PATTERN 仅完全匹配字词</span><br><span class="line">  -x, --line-regexp         强制 PATTERN 仅完全匹配一行</span><br><span class="line">  -z, --null-data           一个 <span class="number">0</span> 字节的数据行，但不是空行</span><br><span class="line">杂项:</span><br><span class="line">  -s, --no-messages         不显示错误信息</span><br><span class="line">  -v, --invert-match        选中不匹配的行</span><br><span class="line">  -V, --version             显示版本信息并退出</span><br><span class="line">      --help                显示此帮助并退出</span><br><span class="line"></span><br><span class="line">输出控制:</span><br><span class="line">  -m, --max-count=NUM       NUM 次匹配后停止</span><br><span class="line">  -b, --byte-offset         输出的同时打印字节偏移</span><br><span class="line">  -n, --line-number         输出的同时打印行号</span><br><span class="line">      --line-buffered       每行输出清空</span><br><span class="line">  -H, --<span class="keyword">with</span>-filename       为每一匹配项打印文件名</span><br><span class="line">  -h, --no-filename         输出时不显示文件名前缀</span><br><span class="line">      --label=LABEL         将LABEL 作为标准输入文件名前缀</span><br><span class="line">  -o, --only-matching       只显示匹配PATTERN 部分的行</span><br><span class="line">  -q, --quiet, --silent     不显示所有常规输出</span><br><span class="line">      --binary-files=TYPE   设定二进制文件的TYPE 类型；</span><br><span class="line">                            TYPE 可以是`binary<span class="string">', `text'</span>, 或`without-match<span class="string">'</span></span><br><span class="line"><span class="string">  -a, --text                等同于 --binary-files=text</span></span><br><span class="line"><span class="string">  -I                        等同于 --binary-files=without-match</span></span><br><span class="line"><span class="string">  -d, --directories=ACTION  读取目录的方式；</span></span><br><span class="line"><span class="string">                            ACTION 可以是`read'</span>, `recurse<span class="string">',或`skip'</span></span><br><span class="line">  -D, --devices=ACTION      读取设备、先入先出队列、套接字的方式；</span><br><span class="line">                            ACTION 可以是`read<span class="string">'或`skip'</span></span><br><span class="line">  -r, --recursive           等同于--directories=recurse</span><br><span class="line">  -R, --dereference-recursive       同上，但遍历所有符号链接</span><br><span class="line">      --include=FILE_PATTERN  只查找匹配FILE_PATTERN 的文件</span><br><span class="line">      --exclude=FILE_PATTERN  跳过匹配FILE_PATTERN 的文件和目录</span><br><span class="line">      --exclude-<span class="keyword">from</span>=FILE   跳过所有除FILE 以外的文件</span><br><span class="line">      --exclude-dir=PATTERN  跳过所有匹配PATTERN 的目录。</span><br><span class="line">  -L, --files-without-match  只打印不匹配FILEs 的文件名</span><br><span class="line">  -l, --files-<span class="keyword">with</span>-matches  只打印匹配FILES 的文件名</span><br><span class="line">  -c, --count               只打印每个FILE 中的匹配行数目</span><br><span class="line">  -T, --initial-tab         行首tabs 分隔（如有必要）</span><br><span class="line">  -Z, --null                在FILE 文件最后打印空字符</span><br><span class="line"></span><br><span class="line">文件控制:</span><br><span class="line">  -B, --before-context=NUM  打印文本及其前面NUM 行</span><br><span class="line">  -A, --after-context=NUM   打印文本及其后面NUM 行</span><br><span class="line">  -C, --context=NUM         打印NUM 行输出文本</span><br><span class="line">  -NUM                      等同于 --context=NUM</span><br><span class="line">      --color[=WHEN],</span><br><span class="line">      --colour[=WHEN]       使用标记高亮匹配字串；</span><br><span class="line">                            WHEN 可以是`always<span class="string">', `never'</span>或`auto<span class="string">'</span></span><br><span class="line"><span class="string">  -U, --binary              不要清除行尾的CR 字符(MSDOS/Windows)</span></span><br><span class="line"><span class="string">  -u, --unix-byte-offsets   忽略CR 字符，报告字节偏移</span></span><br><span class="line"><span class="string">                             (MSDOS/Windows)</span></span><br></pre></td></tr></table></figure><p>对单个文件查找，如果文件较少，我们可以利用cat将文件内容输出到标准控制台，然后使用grep进行字符匹配：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat filepath | grep <span class="string">'string'</span></span><br></pre></td></tr></table></figure><p>或者按照grep前面所示的基本用法<code>grep [选项]... PATTERN [FILE]</code>来查找文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -s string filepath</span><br></pre></td></tr></table></figure><p>对目录下的所有文件进行查找（不查找子目录）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -s string dir</span><br></pre></td></tr></table></figure><p>递归对目录下的所有文件进行查找：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -s -R string dir</span><br></pre></td></tr></table></figure><h2 id="find查找文件"><a href="#find查找文件" class="headerlink" title="find查找文件"></a>find查找文件</h2>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> command </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>libtorch和gflags的编译安装问题</title>
      <link href="/2018/11/15/gflags-and-libtorch-compile-problem/"/>
      <url>/2018/11/15/gflags-and-libtorch-compile-problem/</url>
      
        <content type="html"><![CDATA[<p>这篇文章记录了gflags的安装、libtorch的安装以及过程中的一些问题<br><a id="more"></a></p><h1 id="gflags说明"><a href="#gflags说明" class="headerlink" title="gflags说明"></a>gflags说明</h1><h1 id="libtorch说明"><a href="#libtorch说明" class="headerlink" title="libtorch说明"></a>libtorch说明</h1><h1 id="gflags安装"><a href="#gflags安装" class="headerlink" title="gflags安装"></a>gflags安装</h1><h1 id="libtorch安装"><a href="#libtorch安装" class="headerlink" title="libtorch安装"></a>libtorch安装</h1><h1 id="bug-gflags和libtorch冲突问题"><a href="#bug-gflags和libtorch冲突问题" class="headerlink" title="[bug] gflags和libtorch冲突问题"></a>[bug] gflags和libtorch冲突问题</h1><p>我们可能在CMakeList.txt文件中像这样链接gflags和libtorch的库(error):</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">target_link_libraries(pycvt <span class="string">"$&#123;TORCH_LIBRARIES&#125;"</span> gflags)</span><br><span class="line">备注：其中的pycvt是程序名。</span><br></pre></td></tr></table></figure><p>文件CMakeList.txt中的链接命令是没有问题的，但是我们make编译链接库的过程中，可能会出现下面的问题：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CMakeFiles/pycvt.dir/pycvt.cpp.o：在函数‘main’中：</span><br><span class="line">pycvt.cpp:(.text+<span class="number">0xe1</span>)：对‘google::ParseCommandLineFlags(int*, char***, bool)’未定义的引用</span><br><span class="line">CMakeFiles/pycvt.dir/pycvt.cpp.o：在函数‘__static_initialization_and_destruction_0(int, int)’中：</span><br><span class="line">pycvt.cpp:(.text+<span class="number">0x4c5</span>)：对‘google::FlagRegisterer::FlagRegisterer&lt;std::string&gt;(char const*, char const*, char const*, std::string*, std::string*)’未定义的引用</span><br><span class="line">pycvt.cpp:(.text+<span class="number">0x568</span>)：对‘google::FlagRegisterer::FlagRegisterer&lt;std::string&gt;(char const*, char const*, char const*, std::string*, std::string*)’未定义的引用</span><br><span class="line">pycvt.cpp:(.text+<span class="number">0x60b</span>)：对‘google::FlagRegisterer::FlagRegisterer&lt;std::string&gt;(char const*, char const*, char const*, std::string*, std::string*)’未定义的引用</span><br><span class="line">pycvt.cpp:(.text+<span class="number">0x6ae</span>)：对‘google::FlagRegisterer::FlagRegisterer&lt;std::string&gt;(char const*, char const*, char const*, std::string*, std::string*)’未定义的引用</span><br><span class="line">pycvt.cpp:(.text+<span class="number">0x709</span>)：对‘google::FlagRegisterer::FlagRegisterer&lt;int&gt;(char const*, char const*, char const*, int*, int*)’未定义的引用</span><br><span class="line">pycvt.cpp:(.text+<span class="number">0x72e</span>)：对‘google::FlagRegisterer::FlagRegisterer&lt;int&gt;(char const*, char const*, char const*, int*, int*)’未定义的引用</span><br><span class="line">pycvt.cpp:(.text+<span class="number">0x79b</span>)：对‘google::FlagRegisterer::FlagRegisterer&lt;std::string&gt;(char const*, char const*, char const*, std::string*, std::string*)’未定义的引用</span><br><span class="line">pycvt.cpp:(.text+<span class="number">0x83e</span>)：对‘google::FlagRegisterer::FlagRegisterer&lt;std::string&gt;(char const*, char const*, char const*, std::string*, std::string*)’未定义的引用</span><br></pre></td></tr></table></figure><p>出现这个问题的原因是libtorch中自带了gflags（在c10命名空间下），所以如果我们想使用gflags, 用libtorch自带的就可以了，比如gflags中是这样添加命令的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DEFINE_string(model, <span class="string">"valid"</span>, <span class="string">"the torch model path"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">gflags::ParseCommandLineFlags(&amp;argc, &amp;argv, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>我们换成libtorch库下的gflags，应该是这样的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">C10_DEFINE_string(model, <span class="string">"valid"</span>, <span class="string">"the torch model path"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c10::ParseCommandLineFlags(&amp;argc, &amp;argv);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> gflags </category>
          
          <category> libtorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gflags </tag>
            
            <tag> libtorch </tag>
            
            <tag> install </tag>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>各种安装BUG记录</title>
      <link href="/2018/11/07/install-problems-index/"/>
      <url>/2018/11/07/install-problems-index/</url>
      
        <content type="html"><![CDATA[<p>本博客是一个系列博客，记录了我碰到的各种软件安装问题。<br><a id="more"></a></p><h1 id="Anaconda安装opencv3"><a href="#Anaconda安装opencv3" class="headerlink" title="Anaconda安装opencv3"></a>Anaconda安装opencv3</h1><p>最常见的使用Anaconda安装opencv3的命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install -c menpo opencv3</span><br></pre></td></tr></table></figure><p>如果使用上述命令，可能会出现包冲突问题，我使用conda5.3.0=py37,出现了以下包冲突问题：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">UnsatisfiableError: The following specifications were found to be <span class="keyword">in</span> conflict:</span><br><span class="line">- anaconda5.3.0=py37_0 -&gt; hdf51.10.2=hba1933b_1</span><br><span class="line">- anaconda5.3.0=py37_0 -&gt; mkl-service1.1.2=py37h90e4bf4_5</span><br><span class="line">- anaconda5.3.0=py37_0 -&gt; numexpr2.6.8=py37hd89afb7_0</span><br><span class="line">- anaconda5.3.0=py37_0 -&gt; pango1.42.4=h049681c_0 -&gt; harfbuzz[version='&gt;=1.7.6,&lt;2.0a0']&gt; - anaconda5.3.0=py37_0 -&gt; scikit-learn0.19.2=py37h4989274_0</span><br><span class="line">- opencv3</span><br></pre></td></tr></table></figure><p>解决这个问题参考了<a href="https://github.com/ContinuumIO/anaconda-issues/issues/1674" target="_blank" rel="noopener">这个网址</a>，使用下面的命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install -c conda-forge opencv</span><br></pre></td></tr></table></figure><h1 id="eclipse-c-中不能添加带版本号的库"><a href="#eclipse-c-中不能添加带版本号的库" class="headerlink" title="eclipse c++中不能添加带版本号的库"></a>eclipse c++中不能添加带版本号的库</h1><p>这里以libtorch为例来说明这个情况。</p><p>我们下载libtorch后，解压得到libtorch库如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">libbenchmark.a                    libcaffe2_protos.a     libcudart<span class="number">-5</span>d6d23a3.so<span class="number">.8</span><span class="number">.0</span><span class="number">.61</span>  libnnpack.a                   libnvToolsExt<span class="number">-422e3301</span>.so<span class="number">.1</span>  libonnx_proto.a     libshm.so</span><br><span class="line">libbenchmark_main.a               libcaffe2.so           libgomp<span class="number">-7</span>bcb08ae.so           libnnpack_reference_layers.a  libonnx.a                    libprotobuf.a       libtorch.so</span><br><span class="line">libc10.so                         libclog.a              libgomp<span class="number">-7</span>bcb08ae.so<span class="number">.1</span>         libnvrtc<span class="number">-56</span>d4825a.so          libonnxifi_dummy.so          libprotobuf-lite.a  libtorch.so<span class="number">.1</span></span><br><span class="line">libcaffe2_gpu.so                  libcpuinfo.a           libgtest.a                    libnvrtc<span class="number">-56</span>d4825a.so<span class="number">.8</span><span class="number">.0</span><span class="number">.61</span>   libonnxifi_loader.a          libprotoc.a</span><br><span class="line">libcaffe2_module_test_dynamic.so  libcudart<span class="number">-5</span>d6d23a3.so  libgtest_main.a               libnvrtc-builtins.so          libonnxifi.so                libpthreadpool.a</span><br></pre></td></tr></table></figure><p>上面的库中，我们主要使用libtorch.so, 我们ldd看下libtorch.so的依赖项：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ldd libtorch.so</span><br></pre></td></tr></table></figure><p>得到下面的依赖项：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">maxliu@maxliu-tp:/data/source/libtorch/lib$ ldd libtorch.so</span><br><span class="line">        linux-vdso.so.1 =&gt;  (0x00007ffc1d396000)</span><br><span class="line">        libnvToolsExt-422e3301.so.1 =&gt; /data/source/libtorch/lib/libnvToolsExt-422e3301.so.1 (0x00007f83c70de000)</span><br><span class="line">        libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f83c6eda000)</span><br><span class="line">        librt.so.1 =&gt; /lib/x86_64-linux-gnu/librt.so.1 (0x00007f83c6cd2000)</span><br><span class="line">        libcaffe2.so =&gt; /data/source/libtorch/lib/libcaffe2.so (0x00007f83be54d000)</span><br><span class="line">        libcaffe2_gpu.so =&gt; /data/source/libtorch/lib/libcaffe2_gpu.so (0x00007f839ce71000)</span><br><span class="line">        libc10.so =&gt; /data/source/libtorch/lib/libc10.so (0x00007f839cc59000)</span><br><span class="line">        libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f839ca3c000)</span><br><span class="line">        libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f839c733000)</span><br><span class="line">        libstdc++.so.6 =&gt; /usr/lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007f839c3b1000)</span><br><span class="line">        libgcc_s.so.1 =&gt; /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f839c19b000)</span><br><span class="line">        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f839bdd1000)</span><br><span class="line">        /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> (<span class="number">0x00007f83c809b000</span>)</span><br><span class="line">        libgomp-7bcb08ae.so.1 =&gt; /data/source/libtorch/lib/libgomp-7bcb08ae.so.1 (0x00007f839bba7000)</span><br></pre></td></tr></table></figure><p>我们可以看到libtorch.so依赖libnvToolsExt-422e3301.so.1，这个so文件带版本号，而我们在eclipse中添加库时，只能添加so文件的名字，也就是nvToolsExt-422e3301, eclipse调用g++使用参数-l进行链接，即-lnvToolsExt-422e3301，在实际链接库会自动补上前缀lib和后缀so，所以无法找到带版本号的库，碰到这个问题，我目前还没有找到解决方法，不行的话我们还是写CMakeList来解决吧。</p>]]></content>
      
      
      <categories>
          
          <category> Install Problem </category>
          
      </categories>
      
      
        <tags>
            
            <tag> install </tag>
            
            <tag> index </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux-mount-command</title>
      <link href="/2018/11/07/linux-mount-command/"/>
      <url>/2018/11/07/linux-mount-command/</url>
      
        <content type="html"><![CDATA[<p>这篇博客主要探讨了磁盘（包括U盘）分区和挂载的一些问题。<br><a id="more"></a></p><h1 id="探讨的问题说明"><a href="#探讨的问题说明" class="headerlink" title="探讨的问题说明"></a>探讨的问题说明</h1><ul><li>Linux中的文件系统</li><li>如何对新硬盘进行分区并挂载</li><li>如何对U盘进行挂载</li></ul><h1 id="linux中的文件系统"><a href="#linux中的文件系统" class="headerlink" title="linux中的文件系统"></a>linux中的文件系统</h1><p>首先我们认识下linux中的文件系统</p><h1 id="如何对新硬盘进行分区并挂载"><a href="#如何对新硬盘进行分区并挂载" class="headerlink" title="如何对新硬盘进行分区并挂载"></a>如何对新硬盘进行分区并挂载</h1><p>写作参考网址：<a href="http://www.cnblogs.com/fieldtianye/p/9295986.html" target="_blank" rel="noopener">http://www.cnblogs.com/fieldtianye/p/9295986.html</a></p><h1 id="如何对U盘进行挂载"><a href="#如何对U盘进行挂载" class="headerlink" title="如何对U盘进行挂载"></a>如何对U盘进行挂载</h1>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> command </tag>
            
            <tag> mount </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>i3wm-using-skills</title>
      <link href="/2018/09/30/i3wm-using-skills/"/>
      <url>/2018/09/30/i3wm-using-skills/</url>
      
        <content type="html"><![CDATA[<p>这篇文章记录的是linux下i3窗口管理器的使用方法和技巧<br><a id="more"></a></p>]]></content>
      
      
      <categories>
          
          <category> i3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> i3 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>tmux-using-skills</title>
      <link href="/2018/09/30/tmux-using-skills/"/>
      <url>/2018/09/30/tmux-using-skills/</url>
      
        <content type="html"><![CDATA[<p>这篇文章记录了tmux的一些使用技巧。<br><!--moew--></p><h1 id="启用鼠标滚屏和窗口切换"><a href="#启用鼠标滚屏和窗口切换" class="headerlink" title="启用鼠标滚屏和窗口切换"></a>启用鼠标滚屏和窗口切换</h1><p>我们安装tmux后，默认是没有启用鼠标滚屏的，必须按下<code>Ctrl+b</code>后使用PageUp和PageDown来翻页，这样浏览不如自由滚动窗口方便，我们可以开启鼠标滚屏和窗口切换，编辑tmux的配置文件，配置文件在<code>~/.tmux.conf</code>，如果没有需要自己创建一个，文件中加入下面的指令，这个指令重写了<code>Mouse-mode</code>的一系列指令，包括窗格切换、调整窗格大小、窗口切换(窗口：window，窗格pane),指令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -g mouse on</span><br></pre></td></tr></table></figure><p>使文件生效(不要使用<code>source ~/.tmux.conf</code>,无法识别tmux的指令，例如setw，not found)：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux <span class="built_in">source</span>-file ~/.tmux.conf</span><br></pre></td></tr></table></figure><p>另外启用鼠标后，不能正常的复制tmux中的内容和粘贴，复制tmux中的内容时需要按住<code>Shift</code>键，可以使用<code>Shift+Insert</code>粘贴剪贴板内容到命令行。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Pytorch API中的卷积与反卷积操作</title>
      <link href="/2018/09/27/pytorch-api-Conv-Deconv/"/>
      <url>/2018/09/27/pytorch-api-Conv-Deconv/</url>
      
        <content type="html"><![CDATA[<p>本篇文章解析卷积与反卷积操作以及Pytorch中的相关API<br><a id="more"></a></p>]]></content>
      
      
      <categories>
          
          <category> pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pytorch </tag>
            
            <tag> api </tag>
            
            <tag> 卷积，反卷积 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo搭建个人Blog记录</title>
      <link href="/2018/09/20/hexo-next-blog/"/>
      <url>/2018/09/20/hexo-next-blog/</url>
      
        <content type="html"><![CDATA[<p>记录了整个站点搭建的过程<br><a id="more"></a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>图像视频质量</title>
      <link href="/2018/09/20/image-video-quality/"/>
      <url>/2018/09/20/image-video-quality/</url>
      
        <content type="html"><![CDATA[<p>探究图像和视频质量问题<br><a id="more"></a></p>]]></content>
      
      
      <categories>
          
          <category> Image Process </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AR </tag>
            
            <tag> IQ </tag>
            
            <tag> VQ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Compression Artifacts Removal Using Convolutional Neural Networks</title>
      <link href="/2018/09/20/iccv-2015-arcnn/"/>
      <url>/2018/09/20/iccv-2015-arcnn/</url>
      
        <content type="html"><![CDATA[<p>论文分析，文章2015年发表在ICCV上，使用深度学习做压缩失真消除<br><a id="more"></a></p><p>这是ICCV2015年的一篇文章，算是比较早用深度学习做压缩失真消除，后面的大多数方法都是与这篇文章里面的去除效果做对比。</p>]]></content>
      
      
      <categories>
          
          <category> Deep Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AR </tag>
            
            <tag> CNN </tag>
            
            <tag> ICCV </tag>
            
            <tag> Paper </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Deep Generative Adversarial Compression Artifact Removal</title>
      <link href="/2018/09/20/iccv-2017-gan-ar/"/>
      <url>/2018/09/20/iccv-2017-gan-ar/</url>
      
        <content type="html"><![CDATA[<p>论文分析，文章2017年发表在ICCV上，使用GAN做压缩失真消除<br><a id="more"></a></p><p>这篇文章是2017年ICCV的一篇文章， 主要是用GAN做压缩失真的消除，关于图像和视频压缩失真，前面的文章已经讨论过这个问题，感兴趣的可以查看这篇博客。</p><h3 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h3><p>研究深度网络主要关注一下几点：</p><ul><li>网络架构：本文使用GAN，一个生成网络和一个判别网络，生成网络使用的一个9层的餐差结构</li></ul><p>本文使用GAN，一个生成网络和一个判别网络</p><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p>下图是整个网络结构的架构图</p><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3>]]></content>
      
      
      <categories>
          
          <category> Deep Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AR </tag>
            
            <tag> ICCV </tag>
            
            <tag> Paper </tag>
            
            <tag> GAN </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>liulizhou</title>
      <link href="/2018/09/20/liulizhou/"/>
      <url>/2018/09/20/liulizhou/</url>
      
        <content type="html"><![CDATA[<p>Hello Kitty</p>]]></content>
      
      
      <categories>
          
          <category> 人物 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cute </tag>
            
            <tag> hansome </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
